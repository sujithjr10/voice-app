<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice App</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">
    <div class="bg-white rounded-2xl shadow-2xl p-8 max-w-lg w-full flex flex-col items-center space-y-6">
        <h1 class="text-3xl font-bold text-gray-800 text-center">Voice App</h1>
        <p class="text-gray-500 text-center">Type some text below and click the button to hear it spoken.</p>
        
        <div class="w-full">
            <textarea id="text-input" rows="6" placeholder="Enter text here..."
                      class="w-full p-4 rounded-xl border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all duration-200 resize-none shadow-sm"></textarea>
        </div>
        
        <button id="speak-button"
                class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-full transition-all duration-300 transform hover:scale-105 shadow-md disabled:bg-gray-400 disabled:cursor-not-allowed">
            Speak
        </button>

        <div id="message-container" class="w-full text-center min-h-[1.5rem]">
            <span id="loading-spinner" class="hidden text-blue-600 font-semibold">Generating speech...</span>
        </div>

        <audio id="audio-player" controls class="w-full hidden mt-4"></audio>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const textInput = document.getElementById('text-input');
            const speakButton = document.getElementById('speak-button');
            const audioPlayer = document.getElementById('audio-player');
            const loadingSpinner = document.getElementById('loading-spinner');
            const messageContainer = document.getElementById('message-container');

            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

            const base64ToArrayBuffer = (base64) => {
                const binaryString = window.atob(base64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            };

            const pcmToWav = (pcmData, sampleRate) => {
                const numChannels = 1;
                const bitsPerSample = 16;
                const byteRate = sampleRate * numChannels * bitsPerSample / 8;
                const blockAlign = numChannels * bitsPerSample / 8;
                const dataSize = pcmData.byteLength;
                
                const buffer = new ArrayBuffer(44 + dataSize);
                const view = new DataView(buffer);
                let offset = 0;
                
                // RIFF chunk
                view.setUint32(offset, 0x52494646, false); // "RIFF"
                offset += 4;
                view.setUint32(offset, 36 + dataSize, true); // File size
                offset += 4;
                view.setUint32(offset, 0x57415645, false); // "WAVE"
                offset += 4;
                
                // fmt chunk
                view.setUint32(offset, 0x666d7420, false); // "fmt "
                offset += 4;
                view.setUint32(offset, 16, true); // Subchunk size
                offset += 4;
                view.setUint16(offset, 1, true); // Audio format (1 for PCM)
                offset += 2;
                view.setUint16(offset, numChannels, true);
                offset += 2;
                view.setUint32(offset, sampleRate, true);
                offset += 4;
                view.setUint32(offset, byteRate, true);
                offset += 4;
                view.setUint16(offset, blockAlign, true);
                offset += 2;
                view.setUint16(offset, bitsPerSample, true);
                offset += 2;
                
                // data chunk
                view.setUint32(offset, 0x64617461, false); // "data"
                offset += 4;
                view.setUint32(offset, dataSize, true);
                offset += 4;

                const pcmArray = new Uint8Array(pcmData);
                for (let i = 0; i < pcmArray.length; i++) {
                    view.setUint8(offset + i, pcmArray[i]);
                }

                return new Blob([view], { type: 'audio/wav' });
            };

            const generateSpeech = async (text) => {
                let retries = 3;
                while (retries > 0) {
                    try {
                        const payload = {
                            contents: [{
                                parts: [{ text: text }]
                            }],
                            generationConfig: {
                                responseModalities: ["AUDIO"],
                                speechConfig: {
                                    voiceConfig: {
                                        prebuiltVoiceConfig: { voiceName: "Kore" }
                                    }
                                }
                            },
                            model: "gemini-2.5-flash-preview-tts"
                        };

                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }

                        const result = await response.json();
                        const part = result?.candidates?.[0]?.content?.parts?.[0];
                        const audioData = part?.inlineData?.data;
                        const mimeType = part?.inlineData?.mimeType;

                        if (!audioData || !mimeType) {
                            throw new Error("Invalid API response: Missing audio data.");
                        }

                        const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                        const pcmData = base64ToArrayBuffer(audioData);
                        const wavBlob = pcmToWav(pcmData, sampleRate);
                        const audioUrl = URL.createObjectURL(wavBlob);
                        
                        audioPlayer.src = audioUrl;
                        audioPlayer.style.display = 'block';
                        audioPlayer.play();

                        messageContainer.textContent = '';
                        break; // Success, exit the loop
                    } catch (error) {
                        retries--;
                        console.error("API call failed:", error);
                        if (retries > 0) {
                            messageContainer.textContent = `Error: ${error.message}. Retrying...`;
                            await new Promise(res => setTimeout(res, 2 ** (3 - retries) * 1000)); // Exponential backoff
                        } else {
                            messageContainer.textContent = 'Failed to generate speech after multiple attempts. Please try again.';
                        }
                    }
                }
            };

            speakButton.addEventListener('click', () => {
                const text = textInput.value.trim();
                if (!text) {
                    messageContainer.textContent = "Please enter some text.";
                    return;
                }
                
                speakButton.disabled = true;
                loadingSpinner.style.display = 'block';
                audioPlayer.style.display = 'none';
                messageContainer.textContent = 'Generating speech...';
                
                generateSpeech(text).finally(() => {
                    speakButton.disabled = false;
                    loadingSpinner.style.display = 'none';
                });
            });
        });
    </script>
</body>
</html>
